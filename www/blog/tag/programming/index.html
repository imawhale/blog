<!DOCTYPE html>
<html>
<head>
  <title>programming – Casey Rodarmor's Blog</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="/blog/index.css" rel="stylesheet">
  <link rel="alternate" type="application/rss+xml" href="/blog/feed.xml">
</head>
<body>
  <header class="links">
    <span><a href="/blog/">Casey Rodarmor's Blog</a></span>
    <div class="spacer"></div><a href="/">homepage</a> <a href="mailto:casey@rodarmor.com">mail</a>
    <a href="https://github.com/casey">github</a>
  </header>
  <hr>
  <article>
    <header>
      <a href="/blog/intermodal/" class="title">Intermodal</a> <span class="tags"><a href=
      "/blog/tag/sharing/">sharing</a> · <a href="/blog/tag/programming/">programming</a></span>
    </header>
    <p><em>Intermodal is not intended to be used for unauthorized sharing. Any discussion of
    unauthorized sharing is not permitted in any project space, including GitHub and
    Discord.</em></p>
    <hr>
    <h2>TL;DR</h2>
    <p>I've just published the first release of Intermodal, a command-line BitTorrent metainfo
    utility.</p>
    <p>It can create, display, and verify <code>.torrent</code> files, as well as generate magnet
    links.</p>
    <p>The binary is called <code>imdl</code>.</p>
    <p>Get it <a href="https://github.com/casey/intermodal">here</a>, try it out, and let me know
    what you think!</p>
    <hr>
    <h2>What happened to your personal library?</h2>
    <p>Rows of LPs, shelves of VHS tapes, binders of CDs and DVDs, or maybe hard drives stuffed to
    overflowing.</p>
    <p>It used to be common to maintain a personal content library, but in the last decade, most of
    us stopped. We ditched the tedium of tagging and sorting for Netflix, Spotify, and YouTube.</p>
    <p>Whenever I think about this I feel a wistful longing for the past. And I don't think it's
    just nostalgia.</p>
    <p>Modern content channels are usually designed around a feed and automatic recommendations,
    and don't make a strong distinction between things that are in <em>your</em> library and
    everything else. This makes it too easy to consume content compulsively and replaces active
    search and curation with guzzling down what's on tap, biasing me away from what <em>I</em> like
    and towards what <em>everyone else</em> likes.</p>
    <p>Beyond that, once-accessible items often disappear due to obscure legal and contractual
    machinations out of one's control.</p>
    <p>Worse still, content that is below an invisible popularity threshold is hard to find, not
    available, or doesn't appear in recommendation streams. One of my favorite tracks from my old
    music library was a song from a collection of music by people on Usenet called "It's Six AM and
    Gary's Refrigerator Plays a Raga". Definitely not available on Spotify.</p>
    <p>And, if you make something yourself, you can't just put it into your own library, or send it
    to a friend so they can throw it in theirs.</p>
    <p>This is profoundly saddening.</p>
    <hr>
    <h2>How did we get here?</h2>
    <p>I think we stopped curating our own libraries due to three factors: ease of use, features,
    and incentives. These factors have pushed people away from decentralized content networks, like
    BiTorrrent and store-bought CDs, and towards centralized apps, like Spotify and Netflix.</p>
    <h3>Ease of Use</h3>
    <p>For all their flaws, centralized apps are incredibly easy to use. Just open a browser tab
    and play.</p>
    <p>To get content into your own library and play it, you need to use a number of applications
    in concert­a web browser to search, another app to download, a file browser to organize, and
    finally a player to listen or watch. This is doable, but is a huge chore compared to
    centralized apps.</p>
    <h3>Features</h3>
    <p>Centralized apps maintain large, proprietary databases of metadata, so features like search,
    recommendation, and preview work flawlessly.</p>
    <p>Most desirable features are only as good as the metadata they're built on, so if you're
    curating a personal library, you have to curate the metadata along with it.</p>
    <p>This is the primary reason I gave up on my personal music library: I spent endless amounts
    of time making sure that metadata was uniform and correct, and although I found some great
    tools to help, it still felt like a part-time job.</p>
    <h3>Incentives</h3>
    <p>Centralized apps usually have built-in monetization mechanisms. If you like content you find
    through decentralized channels and want to support the creator or publisher, there is no easy
    means to do so.</p>
    <p>Because of this, first-party releases on decentralized content networks are rare, and
    resources are instead lavished on centralized apps.</p>
    <hr>
    <h2>Where do we go from here?</h2>
    <p>The feature-gap between centralized apps and decentralized content networks is vast.</p>
    <p>Fortunately, there is a relatively simple way that we can close that gap:</p>
    <p>Developing standards for structured, machine-readable metadata in a simple, universal
    format.</p>
    <p>Existing content does contain metadata. However, this metadata is limited to specific
    content types, for example MP3 tags; or modes of transport, for example BitTorrent.</p>
    <p>By developing a standard for metadata manifests that can be accompany content, many
    desirable features become more reliable and dramatically easier to implement:</p>
    <ul>
      <li>
        <p>Newly downloaded releases can be integrated into a library without user intervention. If
        the user has a preferred scheme for naming and tagging, that scheme can be applied
        automatically.</p>
      </li>
      <li>
        <p>Content from a user's library can easily be exported for sharing in a format that's
        appropriate for the transportation medium, for example as a torrent or as a
        <code>.zip</code> archive.</p>
      </li>
      <li>
        <p>By identifying the location and format of content in releases, that content can be
        extracted and transcoded automatically for mobile devices and web browsers.</p>
      </li>
      <li>
        <p>Rich search indices can be built from collections of content, without needing to resort
        to complex and error-prone heuristics.</p>
      </li>
      <li>
        <p>Immutable identifiers, for example ISBN numbers, allow metadata to be automatically
        updated from external sources.</p>
      </li>
      <li>
        <p>Creators and publishers can include a Bitcoin tipping address in their releases, so end
        users can reward them directly.</p>
      </li>
      <li>
        <p>Releases can be signed, allowing users to verify the authenticity of content, and
        allowing publishers to create new releases that explicitly supersede old ones.</p>
      </li>
    </ul>
    <p>Standardized metadata would be a enormous boon to the decentralized content ecosystem, and
    the Intermodal project is my attempt to make this possibility a reality.</p>
    <hr>
    <h2>Intermodal</h2>
    <p>The project for developing these metadata standards, as well as tools and apps to make these
    standards useful, is called "Intermodal".</p>
    <p>Seamless intermodal transportation, enabled by containerization, has led to enormous
    efficiency gains in the transport of physical goods.</p>
    <p>Before the invention of the humble 40' shipping container, and the intermodal transportation
    network that it enabled, the majority of the world's goods were transported as so-called
    <a href="https://en.wikipedia.org/wiki/Break_bulk_cargo">bulk break cargo</a>.</p>
    <p>Bulk break cargo is packed in bags, barrels, boxes, crates, and drums of varying sizes.
    Loading such cargo onto a truck, cargo ship, or train took labor and time, and was a major
    source of friction and cost in the shipping of goods from place to place.</p>
    <p>The invention and standardization of intermodal containers, the 20' and 40' shipping
    containers of today, changed all that. Cargo could now be packed into uniformly sized
    containers of known strength and weight, of a size suitable for transportation by train, truck,
    or ship. This standardization made the once back-breaking work of moving cargo through multiple
    transportation modes easy and fast. What once required teams of stout men could now be done
    easily with cranes and other equipment.</p>
    <p>In many ways, when it comes to decentralized digital content, we are very much living in an
    era of bulk break cargo. Painstaking effort is required to prepare content for transportation
    across different modes, e.g. BitTorrent, the web, or Usenet; and it is either impossible or
    takes complex hueristics to answer simple questions, like what <em>is</em> a piece of content,
    anyways?</p>
    <p>By standardizing metadata, we can make more efficient the conveyance of digital content
    across different modes of transportation, and allow rich services to be built on top of that
    content.</p>
    <p>Thus, "Intermodal".</p>
    <hr>
    <h2><code>imdl</code></h2>
    <p>After much hand-wringing and false starts, I decided that a good place to start would be a
    BitTorrent metainfo (that is to say, <code>.torrent</code> file) creator. The first version is
    full of features and nicities, and is ready for users today.</p>
    <p>The binary is called <code>imdl</code>, and development is hosted <a href=
    "https://github.com/casey/intermodal">on GitHub</a>.</p>
    <p>BitTorrent is widely used, and a torrent creator is much simpler than a torrent client,
    tracker, or index, making a good place to start.</p>
    <p>Although <code>imdl</code> does not today have any groundbreaking new features, and no
    functionality for creating metadata manifests, it is a natural place to start adding such
    features.</p>
    <p><code>imdl</code> is written in Rust. Rust is fast, correct, and makes it easy to distribute
    self-contained binaries to users. Additionally, Rust can be compiled to <a href=
    "https://webassembly.org/">WebAssembly</a>, so bits of <code>imdl</code> might eventually be
    adapted to run in the browser.</p>
    <p><code>imdl</code> will hopefully be extended with all manner of useful features, so
    torrent-creation functionality lives under the <code>torrent</code> subcommand: <code>imdl
    torrent create</code>, <code>imdl torrent verify</code>, <code>imdl torrent show</code>, and so
    on.</p>
    <p>I've tried to add all the useful features of existing torrent file creators that I could
    find, so hopefully <code>imdl</code> is immediately useful. I owe a huge debt of gratitude to
    the <a href="https://imdl.io/book/prior-art.html">many exiting open-source torrent
    creators</a>, which have been a font of inspiration and good ideas.</p>
    <hr>
    <h2>What's next?</h2>
    <p>First and foremost, I want <code>imdl</code> to be a useful torrent creator <em>today</em>.
    If you find any bugs, or have feature requests, don't hesitate to <a href=
    "https://github.com/casey/intermodal/issues/new">open an issue</a> or hop on <a href=
    "https://discord.gg/HaaT5Qz">the discord</a>!</p>
    <p>Contributions of code, documentation, clean up, tests, ideas, and discussion are all
    welcome!</p>
    <p>Beyond that, there are a few possible next steps.</p>
    <p>One possibility is fleshing out the standards for content metadata that I've described
    above. However, I'm not sure it's the right thing to do just yet. I'm worried that without any
    consumers of this metadata, like trackers and indices, I'll be designing for abstract users and
    use-cases, which is always a dangerous way to work.</p>
    <p>Another possibility is adding a simple tracker and web index to <code>imdl</code>. I could
    then work on the metadata standard while adding features that consume this metadata to the
    tracker and index. This would help ensure that the new metadata standard actually enables the
    intended concrete use-cases.</p>
    <p>I think the latter is more likely, but nothing is set in stone.</p>
    <p>Thank you so much for reading this rather long-winded blog post!</p>
    <p><code>imdl</code>, modest though it may be, is a love letter to the world, to sharing, and
    to BitTorrent. I hope you find it useful, and it becomes even more useful in the future.</p>
  </article>
  <hr>
  <article>
    <header>
      <a href="/blog/popcorn-time-should-become-a-browser/" class="title">Popcorn Time Should
      Become a Browser</a> <span class="tags"><a href=
      "/blog/tag/programming/">programming</a></span>
    </header>
    <p><em>I am not a lawyer. This is not legal advice.</em></p>
    <p>Popcorn Time-style video streaming apps seem to be vulnerable to legal action by
    rightsholders.</p>
    <p>For example, the <a href=
    "https://torrentfreak.com/registrar-suspends-popcorn-time-domain-name-following-complaint-200121/">
    popcorntime.sh domain was recently suspended</a>, and <a href=
    "https://torrentfreak.com/operator-of-popcorn-time-info-site-is-liable-for-piracy-supreme-court-rules-200115/">
    the operator of a site which merely provided information about how to obtain and use Popcorn
    Time was sentenced to prison</a>.</p>
    <p>Although given that Popcorn Time's servers do not themselves host infringing content this
    may seem a bit unfair, it is simply the reality of the world we live in.</p>
    <p>It is interesting to note, however, that although web browsers can be used in exactly the
    same way as Popcorn Time, namely searching for and viewing copyrighted movies, the developers
    of web browsers have thus far not faced successful legal challenges.</p>
    <p>I believe that there are two major factors that differentiate Popcorn Time from web
    browsers, and contribute to Popcorn Time's legal vulnerability:</p>
    <ol>
      <li>
        <p>Upon opening a web browser, the user must supply the URL of the site they wish to visit.
        Compare this to Popcorn Time, where upon opening the application for the first time, the
        user is immediately presented with a selection of unlicensed Hollywood movies to
        download.</p>
        <p>This difference greatly weakens Popcorn Time's claims against contributory copyright
        infringement. The developers of Popcorn Time cannot credibly claim to be ignorant to the
        types of movies that their users are downloading, whereas a web browser developer can
        credibly claim that the choice of website to visit is always left to the end user.</p>
      </li>
      <li>
        <p>Web browsers have substantial non-infringing uses. "Substantial non-infringing use" is
        jargon for a legal test used in the United States which protects the creator or purveyor of
        a piece of technology from liability for its use in infringement by users if that
        technology has "substantial non-infringing uses". For the canonical example, see <a href=
        "https://en.wikipedia.org/wiki/Sony_Corp._of_America_v._Universal_City_Studios,_Inc."><em>Sony
        Corp. of America v. Universal City Studios, Inc.</em></a>.</p>
      </li>
    </ol>
    <p>Whereas a web browser provider can rightly claim that there are many websites, <a href=
    "https://youtu.be/2JO3oJybBTw">and it's possible an infringing one might slip in, there would
    be no way of knowing</a>, the popcorn time developers cannot claim the same. There is a single,
    fixed Popcorn Time backend, run by the Popcorn Time team, serving the same search results to
    every user.</p>
    <p>Fortunately, even given the above, I believe that Popcorn Time could implement a small
    number of strategic changes that would allow it to withstand future legal aggression:</p>
    <ul>
      <li>Add a URL bar, like a web browser's, to the top of the current GUI.</li>
      <li>Make the URL bar empty when opening the app for the first time, and display no default
      search results to the user.</li>
      <li>When the user enters a URL, use the existing Popcorn Time API protocol to contact the
      backend at that URL, and begin displaying search results from that backend to the user.</li>
      <li>If the app is closed and re-opened, keep the URL bar and the search results populated
      from the last run of the app.</li>
    </ul>
    <p>These changes would be simple, have a minimal impact on the current (quite excellent!) user
    experience, and leverage interaction flows, i.e. a URL bar, that users already understand.</p>
    <p>Additionally, the Popcorn Time team should create an official default search backend which
    focuses exclusively on free, non-infringing, user-created content.</p>
    <p>These steps would, I believe, nicely protect the developers and distributors of Popcorn Time
    from further legal challenges:</p>
    <ul>
      <li>
        <p>Popcorn Time, when first opened, would display no search results by default, and would
        require the user to direct the app with the URL of a site that they would like to visit.
        This would avoid the current situation where a litigator sitting in front of a judge can
        open the Popcorn Time application, and it will by immediately display a choice selection of
        infringing content, which makes for a terrible first impression.</p>
      </li>
      <li>
        <p>Users of the Popcorn Time application could use it to access both infringing and
        non-infringing content, providing a nice argument that the application does in fact have
        <em>substantial non-infringing uses</em>.</p>
      </li>
      <li>
        <p>Infringement via the application would be entirely at the direction of the end-user, and
        not directly assisted by the default search results provided by the developers.</p>
      </li>
      <li>
        <p>Developers wouldn't be running a search back end with infringing content, which is the
        only component of the current Popcorn Time system that stores problematic metadata about
        infringing content.</p>
      </li>
      <li>
        <p>I suspect that the official free-content focused search backend would be successful and
        useful in its own right.</p>
      </li>
      <li>
        <p>Since the search backend could now be switched by end users, a very large number of
        third-party backends would likely appear, serving content that might not be otherwise
        available from the current Popcorn Time backend.</p>
      </li>
    </ul>
    <p>In short, Popcorn Time should become a browser, and then all those lawyers and their
    handlers can go pound sand.</p>
  </article>
  <hr>
  <article>
    <header>
      <a href="/blog/unix-utilities-in-rust-for-great-success/" class="title">Unix Utilities in
      Rust for Great Success</a> <span class="tags"><a href=
      "/blog/tag/programming/">programming</a></span>
    </header>
    <p>I've often been asked for suggestions for an appropriate first project in Rust, and I think
    that writing a version of a unix utility is a great choice, for a bunch of reasons!</p>
    <ul>
      <li>
        <p>There is a diverse and colorful cast of characters to choose from that all provide an
        appropriate scope and difficulty level, such as:</p>
      </li>
      <li>
        <p><code>tree</code>: Print a graphical representation tree in visual form</p>
      </li>
      <li>
        <p><code>strings</code>: Extract plaintext strings from binary files</p>
      </li>
      <li>
        <p><code>wc</code>: Count the lines, characters, and bytes in a file</p>
      </li>
      <li>
        <p><code>ls</code>: List the contents of a directory</p>
      </li>
      <li>
        <p><code>nc</code>: Read and write bytes to network sockets</p>
      </li>
      <li>
        <p><code>cal</code>: Print a cute text calendar</p>
      </li>
      <li>
        <p><code>cat</code>: Copy streams to stdout</p>
      </li>
      <li>
        <p><code>cut</code>: Extract delimited fields from linewise text records</p>
      </li>
      <li>
        <p><code>sort</code>: Sort lines</p>
      </li>
      <li>
        <p><code>uniq</code>: Print only unique lines</p>
      </li>
      <li>
        <p>The existing implementation provided by your system serves as a specification, giving
        you an idea of how the tool works and whether or not your implementation has the same
        behavior.</p>
      </li>
      <li>
        <p>The core functionality of these utilities is very simple, allowing a learner to quickly
        build something useful. And, many have additional features, allowing a learner to add and
        build if they wish. <code>ls</code> is simple, but <code>ls -l</code> is quite the
        project!</p>
      </li>
      <li>
        <p>Many creative additions are possible, like colorful output, expressive configuration,
        and fun and useful new features.</p>
      </li>
      <li>
        <p>IO and error handling are often front-and-center when writing these utilities, which
        provides a great chance to get used to explicit error handling.</p>
      </li>
      <li>
        <p><a href="https://github.com/TeXitoi/structopt">structopt</a> makes argument parsing a
        breeze. And, by leveraging the type system and custom-derive, it provides a nice example of
        a situation where Rust has enormous advantages over other languages, allowing you to do
        more with less code.</p>
      </li>
      <li>
        <p>Rust binaries are fast to load and run, so performance is on par with native C
        implementations, and often much better than implementations in slower languages.</p>
      </li>
      <li>
        <p>Rust binaries are self-contained, so packaging and distribution is manageable, so you
        can share your work with the world.</p>
      </li>
      <li>
        <p>It's fun to use utilities that you wrote in your day-to-day workflow!</p>
      </li>
      <li>
        <p>There are lots of fabulous examples of utilities in the rust ecosystem, like <a href=
        "https://github.com/BurntSushi/ripgrep">ripgrep</a>, <a href=
        "https://github.com/sharkdp/fd">fd</a>, <a href="https://github.com/sharkdp/bat">bat</a>,
        <a href="https://github.com/ogham/exa">exa</a>, and <a href=
        "https://github.com/sharkdp/hexyl">hexyl</a>. (Damn, David Peter is a beast.)</p>
      </li>
      <li>
        <p>If you're teaching others, a simple utility like <code>strings</code> makes for a great
        demonstration of the basics of the language.</p>
      </li>
    </ul>
    <p>I think whether you start with the book or a project like this depends on the learner.</p>
    <p>I much prefer to jump in and struggle mightily, so I started with a project like this (what
    eventually became <a href="https://github.com/casey/just/">just</a>), but I think a lot of
    people might prefer to start with <a href="https://doc.rust-lang.org/book/">the book</a>, or at
    least parts of the book.</p>
  </article>
  <hr>
  <article>
    <header>
      <a href="/blog/new-rustacean-resources/" class="title">New Rustacean Resources</a>
      <span class="tags"><a href="/blog/tag/programming/">programming</a></span>
    </header>
    <ul>
      <li>
        <p><a href="https://rustup.rs"><em>obtain</em></a></p>
        <p>Rustup is the rust toolchain manager. It can install Rust and keep it up-to-date.</p>
      </li>
      <li>
        <p><a href="https://code.visualstudio.com"><em>write</em></a></p>
        <p>Visual Studio Code is easy to use and has great Rust integration.</p>
      </li>
      <li>
        <p><a href="https://doc.rust-lang.org/book/"><em>read</em></a></p>
        <p>The Rust Book is a comprehensive guide to the entire language.</p>
      </li>
      <li>
        <p><a href="https://play.rust-lang.org"><em>play</em></a></p>
        <p>The Rust Playground allows you to quickly try out and share code snippets.</p>
      </li>
      <li>
        <p><a href="https://github.com/rustlings/rustlings"><em>exercise</em></a></p>
        <p>Rustlings are bite-sized exercises for learning rust.</p>
      </li>
      <li>
        <p><a href="https://discord.gg/bGugdPp"><em>chat</em></a></p>
        <p>The Rust-Lang discord instance is a great place to chat about rust.</p>
      </li>
    </ul>
  </article>
  <hr>
  <article>
    <header>
      <a href="/blog/delinearization/" class="title">Delinearization</a> <span class=
      "tags"><a href="/blog/tag/programming/">programming</a></span>
    </header>
    <p>Programs first crawled from the murky oceans as simple lists of instructions that executed
    in sequence. From these humble beginnings they have since evolved an astonishing number of ways
    of delinearizing.</p>
    <p>In fact, most programming paradigms simply amount to different ways to transform a linear
    source file into a program with nonlinear behavior.</p>
    <p>Some examples:</p>
    <ul>
      <li>gotos that unconditionally jump to another point in the program</li>
      <li>an abort instruction that stops the program at some point other than the end</li>
      <li>a macro facility that substitutes one instruction for one or more other instructions</li>
      <li>a source file concatenation facility that concatenates multiple source files</li>
      <li>an include directive that is substituted for the contents of a source file</li>
      <li>structured repetition and selection, a la for, while, if, and switch</li>
      <li>subroutines and functions</li>
      <li>array oriented programming that replace explicit repetition with implicit repetition</li>
      <li>first class functions which delegation of behavior to the caller</li>
      <li>object oriented programming with dynamic dispatch, which allow the runtime type of an
      object to determine which instructions to execute</li>
      <li>aspect oriented programming, pattern matching against the structure of the call stack to
      execute instructions when functions are called or return</li>
      <li>event driven programming, executing instructions in response to external events</li>
      <li>declarative programming, which essentially delegates execution of one program to
      another</li>
    </ul>
  </article>
</body>
</html>
