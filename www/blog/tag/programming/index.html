<!DOCTYPE html>
<html>
<head>
  <title>programming – Casey Rodarmor's Blog</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="/blog/index.css" rel="stylesheet">
  <link rel="alternate" type="application/rss+xml" href="/blog/feed.xml">
</head>
<body>
  <header class="links">
    <span><a href="/blog/">Casey Rodarmor's Blog</a></span>
    <div class="spacer"></div><a href="/">homepage</a> <a href="mailto:casey@rodarmor.com">mail</a>
    <a href="https://github.com/casey">github</a>
  </header>
  <hr>
  <article>
    <header>
      <a href="/blog/intermodal/" class="title">Intermodal</a> <span class="tags"><a href=
      "/blog/tag/sharing/">sharing</a> · <a href="/blog/tag/programming/">programming</a></span>
    </header>
    <h2>TL;DR</h2>
    <p>Intermodal is a new command-line BitTorrent metainfo<sup class="footnote-reference"><a href=
    "#metainfo">1</a></sup> utility for Linux, Windows, and macOS. The binary is called
    <code>imdl</code>.</p>
    <p>It can create, display, and verify <code>.torrent</code> files, as well as generate magnet
    links.</p>
    <p>It has lots of features and niceties, is easy to install and run, and is hopefully just the
    beginning of an ambitious project to make decentralized content sharing better.</p>
    <p>Get it <a href="https://github.com/casey/intermodal">here</a>, try it out, and let me know
    what you think!</p>
    <div class="center">
      <a href="/blog/intermodal/">⋯</a>
    </div>
  </article>
  <hr>
  <article>
    <header>
      <a href="/blog/popcorn-time-should-become-a-browser/" class="title">Popcorn Time Should
      Become a Browser</a> <span class="tags"><a href=
      "/blog/tag/programming/">programming</a></span>
    </header>
    <p><em>I am not a lawyer. This is not legal advice.</em></p>
    <p>Popcorn Time-style video streaming apps seem to be vulnerable to legal action by
    rightsholders.</p>
    <p>For example, the <a href=
    "https://torrentfreak.com/registrar-suspends-popcorn-time-domain-name-following-complaint-200121/">
    popcorntime.sh domain was recently suspended</a>, and <a href=
    "https://torrentfreak.com/operator-of-popcorn-time-info-site-is-liable-for-piracy-supreme-court-rules-200115/">
    the operator of a site which merely provided information about how to obtain and use Popcorn
    Time was sentenced to prison</a>.</p>
    <p>Although given that Popcorn Time's servers do not themselves host infringing content this
    may seem a bit unfair, it is simply the reality of the world we live in.</p>
    <p>It is interesting to note, however, that although web browsers can be used in exactly the
    same way as Popcorn Time, namely searching for and viewing copyrighted movies, the developers
    of web browsers have thus far not faced successful legal challenges.</p>
    <p>I believe that there are two major factors that differentiate Popcorn Time from web
    browsers, and contribute to Popcorn Time's legal vulnerability:</p>
    <ol>
      <li>
        <p>Upon opening a web browser, the user must supply the URL of the site they wish to visit.
        Compare this to Popcorn Time, where upon opening the application for the first time, the
        user is immediately presented with a selection of unlicensed Hollywood movies to
        download.</p>
        <p>This difference greatly weakens Popcorn Time's claims against contributory copyright
        infringement. The developers of Popcorn Time cannot credibly claim to be ignorant to the
        types of movies that their users are downloading, whereas a web browser developer can
        credibly claim that the choice of website to visit is always left to the end user.</p>
      </li>
      <li>
        <p>Web browsers have substantial non-infringing uses. "Substantial non-infringing use" is
        jargon for a legal test used in the United States which protects the creator or purveyor of
        a piece of technology from liability for its use in infringement by users if that
        technology has "substantial non-infringing uses". For the canonical example, see <a href=
        "https://en.wikipedia.org/wiki/Sony_Corp._of_America_v._Universal_City_Studios,_Inc."><em>Sony
        Corp. of America v. Universal City Studios, Inc.</em></a>.</p>
      </li>
    </ol>
    <p>Whereas a web browser provider can rightly claim that there are many websites, <a href=
    "https://youtu.be/2JO3oJybBTw">and it's possible an infringing one might slip in, there would
    be no way of knowing</a>, the popcorn time developers cannot claim the same. There is a single,
    fixed Popcorn Time backend, run by the Popcorn Time team, serving the same search results to
    every user.</p>
    <p>Fortunately, even given the above, I believe that Popcorn Time could implement a small
    number of strategic changes that would allow it to withstand future legal aggression:</p>
    <ul>
      <li>Add a URL bar, like a web browser's, to the top of the current GUI.</li>
      <li>Make the URL bar empty when opening the app for the first time, and display no default
      search results to the user.</li>
      <li>When the user enters a URL, use the existing Popcorn Time API protocol to contact the
      backend at that URL, and begin displaying search results from that backend to the user.</li>
      <li>If the app is closed and re-opened, keep the URL bar and the search results populated
      from the last run of the app.</li>
    </ul>
    <p>These changes would be simple, have a minimal impact on the current (quite excellent!) user
    experience, and leverage interaction flows, i.e. a URL bar, that users already understand.</p>
    <p>Additionally, the Popcorn Time team should create an official default search backend which
    focuses exclusively on free, non-infringing, user-created content.</p>
    <p>These steps would, I believe, nicely protect the developers and distributors of Popcorn Time
    from further legal challenges:</p>
    <ul>
      <li>
        <p>Popcorn Time, when first opened, would display no search results by default, and would
        require the user to direct the app with the URL of a site that they would like to visit.
        This would avoid the current situation where a litigator sitting in front of a judge can
        open the Popcorn Time application, and it will by immediately display a choice selection of
        infringing content, which makes for a terrible first impression.</p>
      </li>
      <li>
        <p>Users of the Popcorn Time application could use it to access both infringing and
        non-infringing content, providing a nice argument that the application does in fact have
        <em>substantial non-infringing uses</em>.</p>
      </li>
      <li>
        <p>Infringement via the application would be entirely at the direction of the end-user, and
        not directly assisted by the default search results provided by the developers.</p>
      </li>
      <li>
        <p>Developers wouldn't be running a search back end with infringing content, which is the
        only component of the current Popcorn Time system that stores problematic metadata about
        infringing content.</p>
      </li>
      <li>
        <p>I suspect that the official free-content focused search backend would be successful and
        useful in its own right.</p>
      </li>
      <li>
        <p>Since the search backend could now be switched by end users, a very large number of
        third-party backends would likely appear, serving content that might not be otherwise
        available from the current Popcorn Time backend.</p>
      </li>
    </ul>
    <p>In short, Popcorn Time should become a browser, and then all those lawyers and their
    handlers can go pound sand.</p>
  </article>
  <hr>
  <article>
    <header>
      <a href="/blog/unix-utilities-in-rust-for-great-success/" class="title">Unix Utilities in
      Rust for Great Success</a> <span class="tags"><a href=
      "/blog/tag/programming/">programming</a></span>
    </header>
    <p>I've often been asked for suggestions for an appropriate first project in Rust, and I think
    that writing a version of a unix utility is a great choice, for a bunch of reasons!</p>
    <ul>
      <li>
        <p>There is a diverse and colorful cast of characters to choose from that all provide an
        appropriate scope and difficulty level, such as:</p>
      </li>
      <li>
        <p><code>tree</code>: Print a graphical representation tree in visual form</p>
      </li>
      <li>
        <p><code>strings</code>: Extract plaintext strings from binary files</p>
      </li>
      <li>
        <p><code>wc</code>: Count the lines, characters, and bytes in a file</p>
      </li>
      <li>
        <p><code>ls</code>: List the contents of a directory</p>
      </li>
      <li>
        <p><code>nc</code>: Read and write bytes to network sockets</p>
      </li>
      <li>
        <p><code>cal</code>: Print a cute text calendar</p>
      </li>
      <li>
        <p><code>cat</code>: Copy streams to stdout</p>
      </li>
      <li>
        <p><code>cut</code>: Extract delimited fields from linewise text records</p>
      </li>
      <li>
        <p><code>sort</code>: Sort lines</p>
      </li>
      <li>
        <p><code>uniq</code>: Print only unique lines</p>
      </li>
      <li>
        <p>The existing implementation provided by your system serves as a specification, giving
        you an idea of how the tool works and whether or not your implementation has the same
        behavior.</p>
      </li>
      <li>
        <p>The core functionality of these utilities is very simple, allowing a learner to quickly
        build something useful. And, many have additional features, allowing a learner to add and
        build if they wish. <code>ls</code> is simple, but <code>ls -l</code> is quite the
        project!</p>
      </li>
      <li>
        <p>Many creative additions are possible, like colorful output, expressive configuration,
        and fun and useful new features.</p>
      </li>
      <li>
        <p>IO and error handling are often front-and-center when writing these utilities, which
        provides a great chance to get used to explicit error handling.</p>
      </li>
      <li>
        <p><a href="https://github.com/TeXitoi/structopt">structopt</a> makes argument parsing a
        breeze. And, by leveraging the type system and custom-derive, it provides a nice example of
        a situation where Rust has enormous advantages over other languages, allowing you to do
        more with less code.</p>
      </li>
      <li>
        <p>Rust binaries are fast to load and run, so performance is on par with native C
        implementations, and often much better than implementations in slower languages.</p>
      </li>
      <li>
        <p>Rust binaries are self-contained, so packaging and distribution is manageable, so you
        can share your work with the world.</p>
      </li>
      <li>
        <p>It's fun to use utilities that you wrote in your day-to-day workflow!</p>
      </li>
      <li>
        <p>There are lots of fabulous examples of utilities in the rust ecosystem, like <a href=
        "https://github.com/BurntSushi/ripgrep">ripgrep</a>, <a href=
        "https://github.com/sharkdp/fd">fd</a>, <a href="https://github.com/sharkdp/bat">bat</a>,
        <a href="https://github.com/ogham/exa">exa</a>, and <a href=
        "https://github.com/sharkdp/hexyl">hexyl</a>. (Damn, David Peter is a beast.)</p>
      </li>
      <li>
        <p>If you're teaching others, a simple utility like <code>strings</code> makes for a great
        demonstration of the basics of the language.</p>
      </li>
    </ul>
    <p>I think whether you start with the book or a project like this depends on the learner.</p>
    <p>I much prefer to jump in and struggle mightily, so I started with a project like this (what
    eventually became <a href="https://github.com/casey/just/">just</a>), but I think a lot of
    people might prefer to start with <a href="https://doc.rust-lang.org/book/">the book</a>, or at
    least parts of the book.</p>
  </article>
  <hr>
  <article>
    <header>
      <a href="/blog/new-rustacean-resources/" class="title">New Rustacean Resources</a>
      <span class="tags"><a href="/blog/tag/programming/">programming</a></span>
    </header>
    <ul>
      <li>
        <p><a href="https://rustup.rs"><em>obtain</em></a></p>
        <p>Rustup is the rust toolchain manager. It can install Rust and keep it up-to-date.</p>
      </li>
      <li>
        <p><a href="https://code.visualstudio.com"><em>write</em></a></p>
        <p>Visual Studio Code is easy to use and has great Rust integration.</p>
      </li>
      <li>
        <p><a href="https://doc.rust-lang.org/book/"><em>read</em></a></p>
        <p>The Rust Book is a comprehensive guide to the entire language.</p>
      </li>
      <li>
        <p><a href="https://play.rust-lang.org"><em>play</em></a></p>
        <p>The Rust Playground allows you to quickly try out and share code snippets.</p>
      </li>
      <li>
        <p><a href="https://github.com/rustlings/rustlings"><em>exercise</em></a></p>
        <p>Rustlings are bite-sized exercises for learning rust.</p>
      </li>
      <li>
        <p><a href="https://discord.gg/bGugdPp"><em>chat</em></a></p>
        <p>The Rust-Lang discord instance is a great place to chat about rust.</p>
      </li>
    </ul>
  </article>
  <hr>
  <article>
    <header>
      <a href="/blog/delinearization/" class="title">Delinearization</a> <span class=
      "tags"><a href="/blog/tag/programming/">programming</a></span>
    </header>
    <p>Programs first crawled from the murky oceans as simple lists of instructions that executed
    in sequence. From these humble beginnings they have since evolved an astonishing number of ways
    of delinearizing.</p>
    <p>In fact, most programming paradigms simply amount to different ways to transform a linear
    source file into a program with nonlinear behavior.</p>
    <p>Some examples:</p>
    <ul>
      <li>gotos that unconditionally jump to another point in the program</li>
      <li>an abort instruction that stops the program at some point other than the end</li>
      <li>a macro facility that substitutes one instruction for one or more other instructions</li>
      <li>a source file concatenation facility that concatenates multiple source files</li>
      <li>an include directive that is substituted for the contents of a source file</li>
      <li>structured repetition and selection, a la for, while, if, and switch</li>
      <li>subroutines and functions</li>
      <li>array oriented programming that replace explicit repetition with implicit repetition</li>
      <li>first class functions which delegation of behavior to the caller</li>
      <li>object oriented programming with dynamic dispatch, which allow the runtime type of an
      object to determine which instructions to execute</li>
      <li>aspect oriented programming, pattern matching against the structure of the call stack to
      execute instructions when functions are called or return</li>
      <li>event driven programming, executing instructions in response to external events</li>
      <li>declarative programming, which essentially delegates execution of one program to
      another</li>
    </ul>
  </article>
</body>
</html>
